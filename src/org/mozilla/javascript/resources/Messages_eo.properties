# Translated by Mathieu Stumpf Guntz
# Notu : bonvolu helpi pri kungrue verki kun la traduko de mem
# https://docs.google.com/spreadsheets/d/1ZdKCDKyz_6B9Aqbkd3ebCfcVOeX-ojN6li0yUbKpUkg/edit#gid=0
#
# Dum tradukado, bonvolu
# * aldoni la tradukon anta\u016d la komentita fontfrazo
# * duobli la diessignon anta\u016d la jam komentitaj fontfrazoj
# * uzi "#!" anta\u016d komentoj pri la tradukado mem


#! Tiu dokumento celas provizi kongruan vortreto.
#! Tiu do malcelas nek pa\u016dsi la anglajn termojn nek la "tradiciajn" termojn, 
#! kvankam tiu lasta estas ege inkluza en la pripensado.


#! Ofte la programado temas pri referenco, deklari referencon, difini referencon, uzi la referecon
#! a\u016d la referecaton, ktp. 
#! Do sube estas la listo de kontekstoj kie la nocio de referenco etas uzita
#! kaj kiel tio dokumento tradukas ilin


#! La\u016d konteksto pri aliriloj de re\u011distro, traduku per -lok- vortoj
#!        load         store
#!        elloki         enloki
#!
#! La\u016d konteksto pri aliriloj de \u0109efmemoro, traduku per -ej- vortoj
#!
#! La\u016d dosier-mastrum-konteksto, traduku per -ir-
#!        read        write        open                close
#!         eliri        eniri        ekirebligi        irebleksigi (ek-ir-ebl-igi, ir-ebl-eks-igi).
#!
#! La\u016d konteksto pri reto, traduku per -\u015dut-
#!        download        upload        
#!         el\u015duti                al\u015duti
#!
#! La\u016d konteksto pri aliriloj, difinoj, deklaradoj de variablo ktp, traduku per -sign- vortoj
#!                let
#! declare         allocate        define                initialization         assign                 denoting        delete
#!*deklari        asigni                difini                 iniciato                atribui                denotacio        
#!                                                                                indiko
#! signigi        asigni                limsigni        eksigni                ensigni                elsigni                forsigni 
#!
#! Notu ke eks-signi povus esti pli preciza ol forsigni, sed "ekssigni" tro proksimas "eksigni"
#! *tio estas aliaj validaj termoj ke ni ne uzos tie \u0109i.
#!
#! Kelkaj detaloj : 
#! (vidu anka\u016d http://stackoverflow.com/questions/23345554/the-differences-between-initialize-define-declare-a-variable )
#! "x estas variablo" kaj "x estas entjero" estas deklaradoj
#! "0<x<42" kaj  "x \u220b {y+1}" a\u016d "function increment(x){return x+1;}" estas difinado
#! "x = 3" estas asigno, a\u016d signado
#!
#! La\u016d konteksto pri aliriloj de montrilo/referenco (pointers/references)
#! Notu ke oni povas paroli pri 
#! signsigno, kiuj povas egale referi al signsigno, ktp (montrilo, pointers)
#! valorsigno, kiuj povas nur referi al valoro (referenco, reference)
#!
#! some_type foo = 5;            umtipa a\u0135o i\u011du 5                a\u0135o signas 5
#! some_type bar = 6;            umtipa ajno i\u011du 6                ajno signas 6
#! some_type *baz;                    umtipa pera zozo                zozo signigu signsigne
#! some_type &qux = foo;            umtipa eja umo i\u011du a\u0135o        umo signas valorsigne a\u0135on
#! baz = &foo;                    zozo i\u011du a\u0135ejo                        zozo signas a\u0135ejon
#! baz = &bar;                    zozo i\u011du ajnejo                zozo signas ajnejon
#! *baz = 10;                    zozenhavo i\u011du 10                alzozo signas 10
#! foo = *baz                    a\u0135o i\u011du zozenhavo                a\u0135o signas elzozon
#!
#!
#! La\u016d konteksto pri trafo ("scope") de signo, traduku per "-vokebl-"
#!        public                        private                        protected        friend
#!        eksterklasalirebla        memklasalirea                idklasalirebla        elektklasalirebla
#!
#!        extern                         static        
#!        eksterblokalirebla        \u0109iingalirebla
#!                                klaskomuna
#!                                transvoka
#!                                nurtujvokebla
#!
#! La\u016d konteksto pri elemento de tabelo, traduku per "-er-"
#!        table[3][5]
#!        5a3a-tabelero
#!
#! La\u016d konteksto pri objekto , traduku per -ul-
#!        class        instance        extend        new        delete                interface                abstract
#!        klaso        ano                klasidi        anigi        eksanigi         interfaco
#!
#! La\u016d konteksto pri aliriloj de eco (property), traduku per -ec-
#!         get        set
#!          eleci        aleci
#! La\u016d konteksto pri \u015daltfrazoj (jump declarations), traduku per -\u015dalt-
#!        jump                goto                switch*        break                continue        return
#!        (pri)\u015dalti        (pri)al\u015dalti        (pri)en\u015dalti        ekster\u015dalti        (cikl)sekv\u015dalti         (pri)re\u015dalti**
#!
#!        try                 catch                 throw                finally                case        default        
#!        flank\u015daltebli        elflank\u015dalti        flank\u015dalti        finflank\u015dalti        \u015daltejo        \u0109ef\u015daltejo        
#!        prov(\u015dalt)i
#!
#!        except
#!         krom\u015daltu
#!
#! *Notu ke pri "switch", KompLeks parolas pri "\u015dalt\u00b7algebr\u00b7o"
#! http://joostje.komputilo.org/KompLeks/html/SX.html#SxALTALGEBRO
#!
#! * *Uzu "re\u015dalt/i" pri la re\u015daltaj frazoj (angle "return statement"), sed uzu "liver/o" por tiu ke la 
#! funkcio produktas. Funkcioj jam aliflanke uzas liveraj frazoj (angle "yield statement") kiel
#! el\u015daltilo.
#!
#! La\u016d konteksto de krampo, konteksto, kaj simile :
#!         open        close
#!         aperti        malaperti


#! generator -> gener-il/o


#!!!!!!!!!!!!!!!! Nomoj por elementoj de diskursoj
#! statement -> frazo
#! statement (\u00e9nonc\u00e9) -> vortigo
#! statement -> eldiro
#! instruction -> instrukcio
#! clause -> frazparto, (kunordigita) propozicio, 
#! declaration -> deklaro, deklaracio
#! definition -> difino
#! body -> -uj/o
#! block -> -ing/o
#! stream -> fluo
#! content -> enhavo, -tuto




#!!!!!!!!!!!!!!!! Ecoj por elementoj de diskursoj
#! requirement -> postulo
#! assertion -> aserto
#! claim -> pretendo
#! disclaimer -> malpretendo
#! -> ordono
#! instance-> ano, tipano, klasano
#! qualify -> ecigi, kvalifiki, kvalitigi,


#! statement -> eldiro
#! prescription -> preskribo
#! formula -> formulo
#! formulation -> fomulado
#! caption (l\u00e9gende) ->
#! label (libell\u00e9) ->
#! category -> categorio
#! mention -> mencio
#! deklaration -> deklaro
#! -> elparoli
#! -> ali\u011dilo
#! -> mendo
#! -> mendilo
#!


#!  value-> valoro        sed : intervalo
#! pole        -> poluso        sed : interpoli, ekesterpoli 








# Defa\u016dltaj mesa\u011doj dosiero de \u011cavoskripto.
## Default JavaScript messages file.


#! Tradukdecido :
#! "property" -> "eco"
#! "assembly" -> bind-ilo, bindil-igo, ktp la\u016d konteksto
#!
#! Notoj, kaj referencoj
#! \u0135ar mallongigas "Java ARchive", tio estas "Java-arkivo", a\u016d "Java-dosier-formo"
#! http://joostje.komputilo.org/KompLeks/html/AP.html#ASEMBLA-LINGVO
#! http://joostje.komputilo.org/KompLeks/html/B.html#BINDILO


# Jeno estas anstata\u016digita dum la Javarkiv-bindiligado el ec\u0109eno kaj netradukendu
## This is replaced during jar assembly from property string
## and should not be translated
implementation.version = @IMPLEMENTATION.VERSION@


#! "should be accessible" -> al-ir-ebl-end-us


# Por aldoni eraromesa\u011dojn de JavaScript en aparta loka\u0135o,
# kreu novan dosieron \u201cMessages_[loka\u0135o].properties\u201c, kie [loka\u0135o] estas la
# la Java mallonge \u0109eno por tiu loka\u0135o. (ISO 639?
# Vidu https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes)
# Ekzemple mesa\u011doj je Javascripto por pola loka\u0135o lokus en Messages_pl.properties, kaj
# mesa\u011doj por svis-itala loka\u0135o lokus en Messages_it_CH.properties.
# Mesa\u011decdosieroj alireblendus tra la klasirejo (classpath) sub
# org.mozilla.Javascript.resources
#
## To add JavaScript error messages for a particular locale, create a
## new Messages_[locale].properties file, where [locale] is the Java
## string abbreviation for that locale.  For example, JavaScript
## messages for the Polish locale should be located in
## Messages_pl.properties, and messages for the Italian Swiss locale
## should be located in Messages_it_CH.properties.  Message properties
## files should be accessible through the classpath under
## org.mozilla.Javascript.resources
#
# Java.util.ResourceBundle
# Java.text.MessageFormat
#




# iuajnjavklasuzi\u011dinta
## SomeJavaClassWhereUsed


# Kodgeneru
## Codegen
msg.dup.parms =\
        duobligu parametronomo "{0}".
        # Duplicate parameter name "{0}".


#! offset estas "de\u015dovo" la\u016d komputada leksikono
msg.too.big.jump =\
        Programo tro kompleksa: tro granda saltde\u015dovo.
        #Program too complex: too big jump offset.


msg.too.big.index =\
        Programo tro kompleksa: interna indekso superas la 64Kan limiton
# Program too complex: internal index exceeds 64K limit.


msg.while.compiling.fn =\
        Trafis kodgeneraderaro dum funkctradukado "{0}": {1}
        #Encountered code generation error while compiling function "{0}": {1}


msg.while.compiling.script =\
        Trafis kodgeneraderaro dum skripttradukado: {0}
        #Encountered code generation error while compiling script: {0}


# Konteksto
## Context
msg.ctor.not.found =\
        Konstruilo por "{0}" maltrovita.
        #Constructor for "{0}" not found.


msg.not.ctor =\
        "{0}" ne estas konstruilo.
        #"{0}" is not a constructor.


# Funkcobjekto
## FunctionObject


msg.varargs.ctor =\
        Metodo a\u016d konstruilo "{0}" endas statikan kun signaturo
        \u201c(Konteksta kono, Objekttipaj[] argumentoj, Funkcitpa objektkonstruilo, duvalenta ennovesprimo)\u201d\
        por difini konstruilo de variablajn argumentojn.
        #Method or constructor "{0}" must be static with the signature \
        #"(Context cx, Object[] args, Function ctorObj, boolean inNewExpr)" \
        #to define a variable arguments constructor.


msg.varargs.fun =\
        Metodo "{0}" statika signendas kun\
        \u201c(Konteksttipa kono, Skriptebla \u0109ia\u0135o, Objekttipaj[] argumentoj, Funkcitpa funkca\u0135o)\u201d\
        por difini funkctio de variablajn argumentojn.
        #Method "{0}" must be static with the signature \
        #"(Context cx, Scriptable thisObj, Object[] args, Function funObj)" \
        #to define a variable arguments function.


msg.incompat.call =\
        Metodo "{0}" vokita pro malkongrua objekto\
        #Method "{0}" called on incompatible object.


msg.bad.parms =\
        Nekongrutipa pramatero "{0}" en metodo "{1}".
        #Unsupported parameter type "{0}" in method "{1}".


msg.bad.method.return =\
        Nekongrua re\u015dalttipa pramatero "{0}" en metodo "{1}".
        #Unsupported return type "{0}" in method "{1}".


msg.bad.ctor.return =\
        Konstruado de objekto per tipo "{0}" estas malkongrua.
        #Construction of objects of type "{0}" is not supported.


msg.no.overload =\
        Metodo "{0}" okazas plurfoje en la klaso "{1}"
        #Method "{0}" occurs multiple times in class "{1}".


msg.method.not.found =\
        Metodo "{0}" maltrovita en "{1}"
        #Method "{0}" not found in "{1}".
#! Kio estas IR???. "factory" tradukas uzino
#! Vidu http://www.docjar.com/html/api/org/mozilla/Javascript/IRFactory.Java.html
## IRFactory






#! Noto pri "left" kaj "right" en sintakspriskribo : tio ne prave signas la fenomenan strukturon, sed unu de \u011diaj apareblaj formoj. Do bone traduki/esprimi tion, necesas kontekste prav-elektatajn termojn. Sed oni povas remaki ke \u011denerale
#! - \u201cleft" (liva) esprimas pasivformo relate al plenumi\u011do, t.e. termo kiu finas kun -it-, -at-, -ot-
#! - \u201cright" (dekstra) esprimas aktivformo t.e. termo kiu finas kun  "-ant-\u201d
#
#! Tiukaze, la termo parolas pri tiu "statement" (tradukebla kiel frazo, ordono, instrukcio; propozicio la\u016d la komputada leksikno) :
#! for (LeftHandSideExpression in objectExpression) {statement}
#! por\u0109iu([elektit]ero en [iteraciebl]aro) { frazo }
#! \u0109iuade(\u2026){\u2026}
#
#! Do "LeftHandSideExpression" estas iteracia frazero, kiu traktas aktualajn erojn de 
#! iteraciebla esprimo.
#! Kaj la sube "left-hand side of" estas "tipo de elektita ero " a\u016d mallongige "elektertipo"
msg.bad.for.in.lhs =\
        Malvalida elektertipo en por\u0109iua frazo.
        #Invalid left-hand side of for..in loop.


msg.mult.index =\
        Sole unu variablon eblas por\u0109iua frazo.
        #Only one variable allowed in for..in loop.


#! la klasika traduko de "key" estas "\u015dlosilo". Sed uzi "vok-" kiel \u0109efvorto anstata\u016d 
#! semantike plikongrue priskribas. Kaj oni jam parolas pri memvoka funkcio kaj pri voki funkcio.
#! Do sube, ni parolas de "paro de ilo por voki kaj \u011dia asociata valoro", a\u016d mallongige
#! "vok-il-par-o"
#! key                 value                key-value
#! vokantero        vokatero        vokparero
msg.bad.for.in.destruct =\
        Elektero de por\u0109iufrazo tipendas dueran vicon por vokerpare kongrui.
        #Left hand side of for..in loop must be an array of length 2 to accept \
        #key/value pair.
    
#! ne-trans-tipo-povi
msg.cant.convert =\
        Netranstippovas "{0}".
        #Can''t convert to type "{0}".


msg.bad.assign.left =\
        Malvalida asignato en asignfrazo.
        #Invalid assignment left-hand side.


#! result/factor/operand/operator/operation estas tradukebla kiel:
#! \u250c rezulto/faktoro/operando/operatoro/operacio
#! \u2502 rezulto/faktoro/operaciendo/operatoro/operacio
#! \u2502 rezulto/faktoro/operaciodateno/operatoro/operacio
#! \u2502 rezulto/faktoro/operaciiganto/operatoro/operacio
#! \u2514rezulto/operacieco/operacianto/operacisimbolo/operacio
#!  - livera\u0135o/parametro/argumento/funkcinomo/funkcio
#! \u250c bildcelero/bildigeco/bildfontero/bildigilo/bildigo
#! \u2514 bildo/bildeco/bildito/bildilo/bildigo
#
#! "decrement" tradukeblas je "dekrement-",
#! sed "increment" tradukas jene : (al)krementi, plusigi, adicii, aldoni, sinsekvigi
#! do oni povus prefiksi tiujn kun [mal|kontra\u016d]
#! ekzemple, radikigi je sekv-, "[ant\u0103u|post]sinkontra\u016dsekvilo" povas nomi la "--x" kaj "x--" bildiloj.
#! http://joostje.komputilo.org/KompLeks/html/KR.html#KREMENTI
#! 
#! Kun "sekv-" oni povas konstrui :
#! increment         alkrementi        iteracii                alsekvi
#! decrement         dekrementi        kontrauiteracii        elsekvi         
#! interation         la\u016dkremento        iteracio                sekvadilo          vicado
#! iterator        la\u016dkrementilo        iteraciilo         sekvebla\u0135o         vico
#! iterator        la\u016dciklilo        ciklilo                 sekvcikla\u0135o         vico
#!
#!                 termo mem        
#! while ->        dum
#! for ->         por
#! do ->        
#! 
#! 
msg.bad.decr =\
        Malvalida dekrementa bildanto.
        #Invalid decrement operand.


msg.bad.incr =\
        Malvalida dekrementa bildanto
        #Invalid increment operand.


msg.bad.yield =\
        liverado enfunkciendas.
        #yield must be in a function.


msg.yield.parenthesized =\
        liveresprimo interkrampendas.
        #yield expression must be parenthesized.


#! "Native" estas ofte tradukita kiel "indi\u011dena"
#! sed depende de konteksto bazo, fondo, fundo, kerno, soklo kaj simile povas esti pli kongrua
#! Ofte tiu temas pri "la\u016d-baz-sistem-a\u0135o", a\u016d mallongige "la\u016dbaz\u00e2jo".
#! Native (thing) -> la\u016dbaz(um)o


#! La\u016d konteksto
#! Global -> malloka
#! Global -> g\u00eanerala


# la\u016dbazmalloka\u0135o
## NativeGlobal
msg.cant.call.indirect =\
        Funkcio "{0}" direktvokendas, tio malpermesas alinomitan funkcvokadon.
        #Function "{0}" must be called directly, and not by way of a \
        #function of another name.


#! primitive tradukas kiel malderiva\u0135o a\u016d primitiva la\u016d "Lexique des Termes Scientifique - Fran\u00e7ais - Esp\u00e9ranto" (LTS)
#! oni povus paroli pri "sen-pra-tipa", \u0109ar tiu estas pri objekto kies tipo ne havas praaron.
#! "primitive" -> senpratipa
#! intend -> celi
msg.eval.nonstring =\
        Vokado de taksu() kun io ajn alia ke iu senpratipa \u0109envaloro nur liveros la valoron. \
\u0108u \u011di estas tio, kion vi celis?
        #Calling eval() with anything other than a primitive string value will \
        #simply return the value. Is this what you intended?


msg.eval.nonstring.strict =\
        Vokado de taksu() kun io ajn alia ke senpratipa \u0109envaloro malpermiti\u011das striktmodon.
        #Calling eval() with anything other than a primitive string value is not \
        #allowed in strict mode.


msg.bad.destruct.op =\
        Malvalida disstruktura asignato bildanto
        #Invalid destructuring assignment operator


# la\u016dbazvoko
## NativeCall
msg.only.from.new =\
        "{0}" vokendas de novesprimo.
        #"{0}" may only be invoked from a "new" expression.


msg.deprec.ctor =\
        La "{0}" konstruilo estas nepluta\u016dgonta.
        #The "{0}" constructor is deprecated.


# la\u016dbazfunkcio
## NativeFunction
msg.no.function.ref.found =\
        Neniu fonto trovita por trakduki fontsigno {0}
        #no source found to decompile function reference {0}


msg.arg.isnt.array =\
        Dua argumento de Funkctipo.prototipo.apliku tipendas aran
        #second argument to Function.prototype.apply must be an array


# la\u016dbazmalloka\u0135o
## NativeGlobal
msg.bad.esc.mask =\
        Malvalida eskaposignomasko
        #invalid string escape mask


# la\u016dbazjavklaso
## NativeJavaClass


#! instance -> klasano/tipano
#! interface estas tradukebla kiel interfaco a\u016d konektoloko
msg.cant.instantiate =\
        a\u0135igeraro ({0}): klaso {1} estas konektoloka a\u016d abstrakta
        #error instantiating ({0}): class {1} is interface or abstract


msg.bad.ctor.sig =\
        Trovis konstruilon kun malkongrua signaturo: {0} vokanta {1} kun signaturo {2}
        #Found constructor with wrong signature: \
        #{0} calling {1} with signature {2}


msg.not.Java.obj =\
        klaselsignu() kongruendas Javaobjektan.
        #Expected argument to getClass() to be a Java object.


msg.no.Java.ctor =\
        Javakonstruilo de "{0}" kun argumentoj "{1}" maltrovita.
        #Java constructor for "{0}" with arguments "{1}" not found.


# la\u016dbazjavmetodo
## NativeJavaMethod
msg.method.ambiguous =\
        Elektado de Java metodo  {0}.{1}, kiu kongruas kun Javasckriptaj argumenttipoj ({2}) \
estas malpreciza; la elekteblaj metodoj estas: {3}
        #The choice of Java method {0}.{1} matching JavaScript argument types ({2}) is ambiguous; \
        #candidate methods are: {3}


msg.constructor.ambiguous =\
        Elektado de Java konstruilo  {0}, kiu kongruas kun Javasckriptaj argumenttipoj ({1}) \
estas malpreciza; la elekteblaj konstruilo estas: {2}
        #The choice of Java constructor {0} matching JavaScript argument types ({1}) is ambiguous; \
        #candidate constructors are: {2}


# la\u016dbazjavobjekto
## NativeJavaObject
msg.conversion.not.allowed =\
        Transtipado de {0} al {1} ne eblas.
        #Cannot convert {0} to {1}


msg.no.empty.interface.conversion =\
        Transtipado de {0} al konektloka {1} ne eblas sen metodoj.
        #Cannot convert {0} to interface {1} with no methods


#! "signature" ->distingsigno
msg.no.function.interface.conversion =\
        Transtipado de funkcio {0} al konektloko ne eblas \u0109ar \u011di enhvas \
malsamdistingsignajn metodojn
        #Cannot convert function {0} to interface since it contains methods with \
        #different signatures


# la\u016dbazjavpako
## NativeJavaPackage
msg.not.classloader =\
        Konstruilo de "paka\u0135oj" atendas argumentojn, kiu tipo estas Java.lang.Classloader
        #Constructor for "Packages" expects argument of type Java.lang.Classloader


# la\u016dbazregulesprimo
## NativeRegExp
msg.bad.quant =\
        Mavalida kvantilo {0}
        #Invalid quantifier {0}


# large: granda
# back reference: retrofontsigno
msg.overlarge.backref =\
        Eksterlimita granda retrofontsigno {0}
        #Overly large back reference {0}


msg.overlarge.min =\
        Eksterlimita minumumo {0}
        #Overly large minimum {0}


msg.overlarge.max =\
        Eksterlimita maksimumo {0}
        #Overly large maximum {0}


msg.zero.quant =\
        Nula kvantilo {0}
        #Zero quantifier {0}


# \u0109u "subi" estas la bona termo? a\u016d \u0109u tio pli kutime alie esprimi\u011das?
msg.max.lt.min =\
        Maksimumo {0} subminimumas
        #Maximum {0} less than minimum


msg.unterm.quant =\
        Malfinita kvantilo {0}
        #Unterminated quantifier {0}


# enkrampfrazo
## parenthetical 
msg.unterm.paren =\
        Malfinita krampfrazo {0}
        #Unterminated parenthetical {0}


msg.unterm.class =\
        Malfinita signa klaso {0}
        #Unterminated character class {0}


# "range"-> intervalo
msg.bad.range =\
        Malvalida intervalo en signklaso.
        #Invalid range in character class.


# La\u016d konteksto : 
# Trailing -> fina
# Trailing ->ekstrema\u0135a
# Trailing ->postsekvanta
msg.trail.backslash =\
        Fina \\ en regula esprimo.
        #Trailing \\ in regular expression.


msg.re.unmatched.right.paren =\
        Malkonguata ) en regula esprimo.
        #unmatched ) in regular expression.


msg.no.regexp =\
        Raciesprimo estas maldisponebla.
        #Regular expressions are not available.


msg.bad.backref =\
        retrofontsigno superas nombron de kaptita kromo.
        #back-reference exceeds number of capturing parentheses.


msg.bad.regexp.compile =\
        Nur unu argumento estas specifiebla kiam la unua argumento de \
        regulesprimo.pratipo.traduku estas regulesprimobjekto.
        #Only one argument may be specified if the first argument to \
        #RegExp.prototype.compile is a RegExp object.


# Parser
# sintaks-analizilo
msg.got.syntax.errors = \
        Tradukado produktis {0} sintakseraroj.
        #Compilation produced {0} syntax errors.


msg.var.redecl =\
        tiperaro: redeklaro de variablo {0}.
        #TypeError: redeclaration of var {0}.


msg.const.redecl =\
        tiperaro: redeklaro de konstato {0}.
        #TypeError: redeclaration of const {0}.
    
msg.let.redecl =\
        tiperaro: redeklaro de variablo {0}.
        #TypeError: redeclaration of variable {0}.


msg.parm.redecl =\
        tiperaro: redeklaro de formala parametro {0}.
    #TypeError: redeclaration of formal parameter {0}.


msg.fn.redecl =\
        tiperaro: redeklaro de funkcio {0}.
        #TypeError: redeclaration of function {0}.


# "let" -> signu
msg.let.decl.not.in.block =\
        sintakseraro: nerektinga "signu"-deklarado
        SyntaxError: let declaration not directly within block


# nodotransformilo
## NodeTransformer


msg.dup.label =\
        duobligita marko
        #duplicated label


msg.undef.label =\
        nedifinita marko
        #undefined label


# break?
msg.bad.break =\
        nemarkita elirejo devas esti en interacio a\u016d en\u015dalto
        #unlabelled break must be inside loop or switch


msg.continue.outside =\
        sekvitiracu devas esti en iteracio
        #continue must be inside loop


msg.continue.nonloop =\
        sekvitiracu nur povas uzi markojn de iteracideklaroj
        continue can only use labeles of iteration statements


#! "keyword" estas tradicie tradukita "\u015dlosilvorto", sed tie "\u015dloso" ne signas iun ajn
#! konkretan a\u0135on tie \u0109i.
#! Pli kontekste senca traduko parolus pri "vorta elemento kiu aperas en la la gramatika difino de #! la programlingvo".
#! La \u0109efaj vortoj de tiu \u0109i difino estas certe "gramatika" kaj "elemento". Do "gramatikero" 
#! certe pli bone indikas la priparolantan a\u0135on ol "\u015dlosilvorto".
#! Alia eblo estas paroli pri "\u0109efaj/bazaj simbolaj elementoj de la programlingvo", bazlingveroj,
#! bazeroj, bazsimboloj, a\u016d bazsigno. Notu ke kutime oni parolas pri "simboltabelo".
#! keyword -> bazsigno


#! Line terminator/end of line marker/EOL etc. -> linifinigilo 
#! File terminator/end of filemarker/EOF etc. -> dosierfinigilo 


msg.bad.throw.eol =\
        linifinigilo estas malpermisita inter "\u0135etu" bazsimbolo kaj \u0135etesprimo.
        #Line terminator is not allowed between the throw keyword and throw \
        #expression.


msg.no.paren.parms =\
        Mankanta apertanta krampo "(" anta\u016d funkciparametroj.
        #missing ( before function parameters.


msg.no.parm =\
        Mankanta formala parametro
        #missing formal parameter


msg.no.paren.after.parms =\
        Mankanta malapertanta krampo ")" post formalaj parametroj.
        #missing ) after formal parameters


# difinujo
## body
msg.no.brace.body =\
        Mankanta apertanta kunigkrampo '{' anta\u016d la funkcia difinujo
        #missing '{' before function body


msg.no.brace.after.body =\
        Mankanta kunigkromo "}" post la funkcia difinujo
        #missing } after function body


msg.no.paren.cond =\
        Mankanta apertanta  krampo "(" anta\u016d kondi\u0109o.
        #missing ( before condition


msg.no.paren.after.cond =\
        Mankanta malapertanta kromo ")" post
        #missing ) after condition


msg.no.semi.stmt =\
        Mankanta punktokomo ";" anta\u016d frazo
        #missing ; before statement


# tiu operatoro permisas aliri elementojn de objekto, do tiu estas "ilo kiu permisas al-iri ero", a\u016d "eralirilo"
msg.no.name.after.dot =\
        mankanta nomo post eralirila operatoro "."
        #missing name after . operator


msg.no.name.after.coloncolon =\
        mankanta nomo post eraligila operatoro "::"
        #missing name after :: operator


msg.no.name.after.dotdot =\
        Mankanta nomo post kun\u0109eniga operatoro ".."
        #missing name after .. operator


msg.no.name.after.xmlAttr =\
        mankanta nomo post .@
        #missing name after .@


# en\u015dalti
## switch
msg.no.bracket.index =\
        Mankanta malapertanta rektkrampo ] de indeksesprimo
        #missing ] in index expression


msg.no.paren.switch =\
        Mankanta ( anta\u016d en\u015daltesprimo
        #missing ( before switch expression


msg.no.paren.after.switch =\
        mankanta ) post en\u015daltesprimo
        #missing ) after switch expression


msg.no.brace.switch =\
        mankanta '{' anta\u016d en\u015dultujo
        #missing '{' before switch body


msg.bad.switch =\
        Malvalida en\u015daltfrazo
        #invalid switch statement


msg.no.colon.case =\
        mankanta dupunkto ":" post kazesprimo
        #missing : after case expression


msg.double.switch.default =\
        duobla "defa\u016dlte" marko en la en\u015daltfrazo
        #double default label in the switch statement


msg.no.while.do =\
        Mankanta "dum" post la interna parto de finkondi\u0109a iteraciujo
        #missing while after do-loop body


msg.no.paren.for =\
        Mankanta aperta kromo "(" post "por"
        missing ( after for


# initializer -> ek- -il- -o
msg.no.semi.for =\
        mankanta ";" post por-cickla ekilo
        #missing ; after for-loop initializer


msg.no.semi.for.cond =\
        mankanta ";" post kondi\u0109o de \u0109iuera iteracio 
        #missing ; after for-loop condition
    
msg.in.after.for.name =\
        mankanta "en" post "por"
        #missing in after for
#! control -> stir-
msg.no.paren.for.ctrl =\
        mankanta ")" post stirilo de \u0109iuera iteracio 
        #missing ) after for-loop control


msg.no.paren.with =\
        mankanta "(" anta\u016d objekto de kun-frazo
        #missing ( before with-statement object


msg.no.paren.after.with =\
        mankanta ")" post objekto de kun-frazo 
        #missing ) after with-statement object


msg.no.paren.after.let =\
        mankanta "(" post "signu"
        #missing ( after let


msg.no.paren.let =\
        mankanta ")" post variablolisto
        #missing ) after variable list


msg.no.curly.let =\
        mankanta "}" post "signu"-frazo
        #missing } after let statement


# return -> (pri)re\u015dalt/i
msg.bad.return =\
        malvalida re\u015dalto
        #invalid return


msg.no.brace.block =\
        mankanta "}" en kunmetita frazo
        #missing } in compound statement


msg.bad.label =\
        malvalida marko
        #invalid label


msg.bad.var =\
        mankanta signo de variablo
        missing variable name


msg.bad.var.init =\
        malvalida variablo ekado
        #invalid variable initialization


msg.no.colon.cond =\
        mankanta ":" en kondi\u0109a esprimo
        #missing : in conditional expression


msg.no.paren.arg =\
        mankanta ")" post argumentlisto
        #missing ) after argument list


msg.no.bracket.arg =\
        mankanta "]" post erlisto
        #missing ] after element list


#! id(entifier) -> identifi -il- -o
#! sam- asocii -il- o : samasociilo
#! kunigi -> samkunigilo
## id
msg.bad.prop =\
        malvalida eca identifilo
        #invalid property id


msg.no.colon.prop =\
        mankanta la dupunkto ":" post eca identifilo
        #missing : after property id
#! Tradukdecido
#! La\u016d konteksto de krampo,  kaj simile :
#! "open/close" -> "aperti/malaperti"
#! 
#! Vidu http://en.lernu.net/komunikado/forumo/temo.php?t=8452&p=4
#! Krome tiu faras plej la\u016dtempanaliza senco de unue fari kaj poste malfari ol la inversa.
msg.no.brace.prop =\
        Mankanta malapertanta kuniga krampo "}" post eca listo
        #missing } after property list
# enkrampfrazo
## parenthetical -
msg.no.paren =\
        mankanta ")" en kromeco
        #missing ) in parenthetical


msg.reserved.id =\
        identifilo estas rezervita vorto
        #identifier is a reserved word


msg.no.paren.catch =\
        mankanta "(" anta\u016d elflank\u015daltinga kondicio
        #missing ( before catch-block condition


msg.bad.catchcond =\
        malvalida elflank\u015daltinga kondicio
        #invalid catch block condition


msg.catch.unreachable =\
        iu ajn elflank\u015dalta frazparto, kiu sekvantas maleciga elflank\u015dalto estas malatingebla
        #any catch clauses following an unqualified catch are unreachable


msg.no.brace.try =\
        mankanta '{' anta\u016d flank\u015dalteblingo
        #missing '{' before try block


msg.no.brace.catchblock =\
        mankanta '{' anta\u016d elflank\u015daltingujo
        #missing '{' before catch-block body


msg.try.no.catchfinally =\
        flank\u015dalteblo sen elflank\u015dalto a\u016d finflank\u015dalto
        #''try'' without ''catch'' or ''finally''


msg.no.return.value =\
        funkcio {0} ne \u0109iam prire\u015daltu valoron.
#function {0} does not always return a value




#! anonymous -> sennoma
msg.anon.no.return.value =\
  sennoma funkcio ne \u0109iam prire\u015daltu valoron
  #anonymous function does not always return a value


msg.return.inconsistent =\
  re\u015dalta frazo malkongruas kun anta\u016d uzado
  #return statement is inconsistent with previous usage


msg.generator.returns =\
  tiperaro: generila funkcio {0} prire\u015daltu valoron
  #TypeError: generator function {0} returns a value


msg.anon.generator.returns =\
  tiperaro: sennoma generila funkcio liveras valoron.
  #TypeError: anonymous generator function returns a value


msg.syntax =\
        sintakseraro
        #syntax error


msg.unexpected.eof =\
        Malantenta dosierfino
        #Unexpected end of file


#! legal" supozas tro le\u011dfaka vortprovizo. Lasu le\u011dojn por le\u011daforj.
#! Plej ofe, frazoj temas pri kongrua a\u016d malkongrua rilato inter arbitra arta regulo kaj okaza\u0135o
#! Do, temas pri "regulo" kaj "kongrui", kaj la\u016d konteksto:
#! "legal" -> kongrua
#! "legal" -> regula
#! "legal" -> la\u016d(um)a 
# ??? \u0109u "regulo" tradukas "rule", kiel arbitra gramatika principo
msg.XML.bad.form =\
        malkongrua fomita XMLa sintakso
        #illegally formed XML syntax
#! Runtime :
#! interpretilo                 procezilo         rulilo
#! interprettempa        proceztempa        rultempa
#! http://komputeko.net/index_en.php?vorto=runtime
#! http://joostje.komputilo.org/KompLeks/html/RI.html#RULTEMPA 
msg.XML.not.available =\
        XMLa rulilo nehavebla
        #XML runtime not available


#! La jam uzadaj ebloj estas rikuro, rekurso, rikursio, rikuro
#! Sed semantike, tio estas pri "meminga objekto", kaj pli precize \u0109i-tie "memvoka funkcio"
#! recursion -> memvokado
#! Vidu anka\u016d https://eo.wikipedia.org/wiki/Rikuro 
msg.too.deep.parser.recursion =\
        Troprofunda memvokado dum sintaksanalizo
        #Too deep recursion while parsing


msg.no.side.effects =\
        Kodo ne havas kromefiko
        #Code has no side effects


msg.extra.trailing.comma =\
        Finkomo malkongruas je ECMA-262a ekilo de objekto. 
        #Trailing comma is not legal in an ECMA-262 object initializer


msg.equal.as.assign =\
        \u0108u okuris mistajpon de asigna\u0135o (=) anstata\u016d testo (==)?
        #Test for equality (==) mistyped as assignment (=)?


msg.var.hides.arg =\
        Variablo {0} ka\u015das argumenton
        #Variable {0} hides argument


msg.destruct.assign.no.init =\
        Mankanta egalsigno "=" en disstruckranta deklaro
        #Missing = in destructuring declaration


# skriptrulilo
## ScriptRuntime
msg.no.properties =\
        {0} ne havas ecojn.
        #{0} has no properties.


msg.invalid.iterator =\
        Nevalida ciklilo valoro
        #Invalid iterator value


msg.iterator.primitive =\
        __ciklilo__ liveris senpratipan voloron
        __iterator__ returned a primitive value


msg.assn.create.strict =\
        Asigna\u0135o al nedeklarita variablo {0}
        #Assignment to undeclared variable {0}


#! Tradukdecido
#! "Reference" tradukeblas per "referenco" kaj "fontindiko".
#! Kaj indiko estas sinonimo de "anta\u016dsigno".
#! Do ni povus uzi "fontanta\u016dsigno" se ni volus esti kaj plejpreciza, kaj plejradikekonomia.
#! Ja "signo" estas jam multe uzita en aliaj tradukproponoj por emfazi la rilatojn inter nocioj.
#! Sed anka\u016d la elektaj termoj mallongendu, do la elektita termo estas "fontsigno".
#! "Reference" -> fontsigno
#!
#! Notu anka\u016d ke "fontsigno" kaj "referenco" amba\u016d ennombras 9 literoj.
#! Inverse "difini" (6 literoj) estas mallonga ol "persignigi" (10 literoj) a\u016d e\u0109 "persigni" (8 literoj). 
msg.ref.undefined.prop =\
        Fontsigno al maldifinita eco "{0}"
        #Reference to undefined property "{0}"


msg.prop.not.found =\
        Netrovita eco {0}.
        #Property {0} not found.


#! kiam temas pri ecoj (objektaj atribuoj):
#! "getter/setter" -> "ecelilo/ecalilo"
#! kiam temas pri simpla variablo:
#! "getter/setter" -> "elsignilo/alsignilo"
#! "get/set" -> "elsigno/alsigno", kiel la konteksto estas pri aliro de eco.
#! Kiam la konteksto estas asignfrazo (kiel "a=0"), uzendu je "asigni".
msg.set.prop.no.setter =\
        Nealsignebla eco {0} kiu nur enhavas ecelilon.
        #Cannot set property {0} that has only a getter.


msg.invalid.type =\
        Nevalida Javaskripta valoro por tipo {0}
        #Invalid JavaScript value of type {0}


#! primitive -> senpratipa
msg.primitive.expected =\
        Atendu senpratipan tipon (ricevis {0} anstata\u016d)
        #Primitive type expected (had {0} instead)


msg.namespace.expected =\
        Atendu nomspacan objekton live de la regiona operatoro "::" (okazis {0} anstata\u016d)
        #Namespace object expected to left of :: (found {0} instead)


#! convert/cast/transtyping -> transtip/i
msg.null.to.object =\
        Nepermisita transtipado de senvalora al objekta.
        #Cannot convert null to an object.


msg.undef.to.object =\
Nepermisita transtipado de nedifinita al objekta.
        #Cannot convert undefined to an object.


msg.cyclic.value =\
        Nepermisita cikla valoro je {0}.
        #Cyclic {0} value not allowed.


msg.is.not.defined =\
        "{0}" estas nedifinita. 
        #"{0}" is not defined.


#! La\u016d dosier-mastrum-konteksto, traduku "read/write/open/close"
#! kiel eliri/eniri/ekirebligi/irebleksig (ek-ir-ebl-igi, ir-ebl-eks-igi).
#! La\u016d konteksto pri aliriloj de eco , traduku "read/write/create/delete
#! kiel elsigni/alsigni/eksigni/forsigni (ek-signi, for-signi)
#! Notu ke eks-signi povus esti pli preciza sed "ekssigni" tro proksimas "eksigni"
msg.undef.prop.read =\
        Malelsignebla eco "{1}" el {0}
        #Cannot read property "{1}" from {0}


msg.undef.prop.write =\
        Malensignebla eco "{1}" el {0} al "{2}"
        #Cannot set property "{1}" of {0} to "{2}"


msg.undef.prop.delete =\
        Malforsignebla eco "{1}" el {0}
        #Cannot delete property "{1}" of {0}


#! Etimologie, "method" kunigas \u03bc\u03b5\u03c4\u03ac (la\u016d-, tra-, trans-) kaj \u1f41\u03b4\u03cc\u03c2 (vojo), kaj signifas "peli vojo". 
#! Tiu diris, \u0109i-tie metodo nomas funkciajn enhavojn de objektoj, kiel "property" nomas atributajn enhavojn de objektoj. Kaj kiel por la tradukdecido de "property" per "eco", "metodo" estos tradukita, tie kontekste, per "ilo".
#! Tiu kongruas kun la anta\u016ddecido de traduki "get/set" per "elsignif-il-o/alsignif-il-o"
#! Kaj semantike, tiu kungruas \u0109ar metodo estas ilo per tiu, kiu oni interagas kun objekto
#! "method" -> ilo


msg.undef.method.call =\
        Malvokebla ilo je "{1}" de {0}
        #Cannot call method "{1}" of {0}


msg.undef.with =\
        Malpermisita uzado de "kun" por {0}
        #Cannot apply "with" to {0}


msg.isnt.function =\
        {0} maltiptaugas funkcion, tiu tipas je {1}
        #{0} is not a function, it is {1}.


msg.isnt.function.in =\
        Malvokebla eco {0} en objeko je {1}. Tiu maltipta\u016dgas funkcion, tiu tipas je "{2}".
        #Cannot call property {0} in object {1}. It is not a function, it is "{2}".


msg.function.not.found =\
        Maltrovita funkcio je {0}.
        #Cannot find function {0}.


msg.function.not.found.in =\
        Maltrovebla funkcio {0} en objekto je {1}.
        #Cannot find function {0} in object {1}.


msg.isnt.xml.object =\
        {0} maltipta\u016dgas XML-objekton.
        #{0} is not an xml object.


msg.no.ref.to.get =\
        {0} ne estas fontsigno por elsigni fontsignan valoron.
        #{0} is not a reference to read reference value.


msg.no.ref.to.set =\
{0} ne estas fontsigno por alsigni fontsignan valoron al {1}.
        #{0} is not a reference to set reference value to {1}.


msg.no.ref.from.function =\
        Funkcio {0} neuzeblas kiel asignata signo de asignado a\u016d kiel operando de inkrementa \
        a\u016d dekrementa operatoro. 
        #Function {0} can not be used as the left-hand side of assignment \
        #or as an operand of ++ or -- operator.


msg.bad.default.value =\
        defa\u016dltvalordonu() metodo de Objekto liveris objekton.
        #Object''s getDefaultValue() method returned an object.


#! instanceof  -> klas-ul-ta\u016dgu
msg.instanceof.not.object = \
        "klasulta\u016dgu" ne estas uzebla kun neobjektipo. 
        #Can''t use instanceof on a non-object.


msg.instanceof.bad.prototype = \
        "prototipo"-eco de {0} maltipta\u016dgas objekton.
        #''prototype'' property of {0} is not an object.


msg.bad.radix = \
        Malkongrua nombra bazo {0}.
        #illegal radix {0}.


# Skripteblobjekto
## ScriptableObject
msg.default.value =\
        Netroveble defa\u016dlta valoro de objekto.
        #Cannot find default value for object.


msg.zero.arg.ctor =\
        klaso "{0}" ne estas \u015dar\u011debla, kiu ne havas senparametro kontruilo.
        #Cannot load class "{0}" which has no zero-parameter constructor.


duplicate.defineClass.name =\
        Nevalida metodo "{0}": nomo "{1}" jam estas uzita. 
        #Invalid method "{0}": name "{1}" is already in use.


msg.ctor.multiple.parms =\
        Ne povas difini konstruilo a\u016d klaso {0} kiel plej ol unu konstruilo havas plurajn parametrojn.
        #Can''t define constructor or class {0} since more than one \
        #constructor has multiple parameters.


#! extend ->klasidi/tipidi


msg.extend.scriptable =\
        {0} tipidendas "skripteblobjekto" por difini econ je {1}.
        #{0} must extend ScriptableObject in order to define property {1}.


msg.bad.getter.parms =\
        Por difini econ, ecelilo je {0} enhavendas nul parametron a\u016d nur unu skripteblobjektan \
parametron.
        #In order to define a property, getter {0} must have zero parameters \
        #or a single ScriptableObject parameter.


msg.obj.getter.parms =\
        Atendas klaskomuna a\u016d delega eecilo {0} por preni scripteblobjektan parametron.
        #Expected static or delegated getter {0} to take a ScriptableObject parameter.


msg.getter.static =\
        ecelilo kaj ecalilo devi amba\u016d esti klaskomuna a\u016d neklaskomuna.
        #Getter and setter must both be static or neither be static.


msg.setter.return =\
        ecalilo devas enhavi vakan livertipon: {0}
        #Setter must have void return type: {0}


msg.setter2.parms =\
        Duparametra ecalilo devas preni skripteblobjekto kiel unua parametro.
        #Two-parameter setter must take a ScriptableObject as its first parameter.


msg.setter1.parms =\
        Atendis unuopa parametro de ecalilo por {0}
        #Expected single parameter setter for {0}


msg.setter2.expected =\
        Atendis klaskomuna a\u016d delega ecalilo {0}, kiu prenas du parametrojn.
        #Expected static or delegated setter {0} to take two parameters.


msg.setter.parms =\
        Atendis a\u016d unu parametro a\u016d du parametroj por ecalilo.
        #Expected either one or two parameters for setter.


msg.setter.bad.type =\
        Mal\u011dusta parametrotipo "{0}" por ecalilo "{1}".
        #Unsupported parameter type "{0}" in setter "{1}".


#! "to seal" -> sigeli, definitivigi, finitigi nealiebligi [ne-ali-ebl-igi], ne\u015dan\u011debligi, neevoluebligi
#! Tradukdecido : finit(ig)-
msg.add.sealed =\
        Malpermisita aldono al finita objekto: {0}.
        #Cannot add a property to a sealed object: {0}.


msg.remove.sealed =\
        Malpermisita forigo de eco el finita objekto: {0}.
        #Cannot remove a property from a sealed object: {0}.


msg.modify.sealed =\
        Malpermisita modifo de eco el finita objekto: {0}.
        #Cannot modify a property of a sealed object: {0}.


msg.modify.readonly =\
        Malpermisita modifo de nurelsignebla eco: {0}
        #Cannot modify readonly property: {0}.


# erfluoj
## TokenStream
msg.missing.exponent =\
        Mankanta eksponento
        #missing exponent


msg.caught.nfe =\
        nombrforma eraro
        #number format error


msg.unterminated.string.lit =\
        nefinita \u0109ena la\u016dlitero
        #unterminated string literal


msg.unterminated.comment =\
        nefinita komento
        #unterminated comment


msg.unterminated.re.lit =\
        nefinita regulesprima litero la\u016dsigno
        #unterminated regular expression literal


msg.invalid.re.flag =\
        malvalida indikilo post regulesprimo
        #invalid flag after regular expression


# kiel traduki input/output ?
msg.no.re.input.for =\
        neniu eniga\u0135o por {0}
        #no input for {0}


msg.illegal.character =\
        malkongrua signo
        #illegal character


#! escape -> kod\u015dan\u011da signo
msg.invalid.escape =\
        malvalida unikodo kod\u015dan\u011dsigna sinsekvo
        #invalid Unicode escape sequence


# frazo
## statement 
msg.bad.namespace =\
        malvalida deklaro de defa\u016dlta nomspaca frazo. \
        Sintakso estas: defa\u016dlta xmla nomspaco = ESPRIMO;
        #not a valid default namespace statement. \
        #Syntax is: default xml namespace = EXPRESSION;


#! La\u016d konteksto
#! token -> ero / parto [tokenizer : vorta dis(part)igilo]
#! token -> \u0135etono [security token : sekuriga \u0135etono] / stafeto [token ring : stafetringo]
#! token -> simbolo
#! http://komputeko.net/index_en.php?vorto=token
#! http://joostje.komputilo.org/KompLeks/html/SI.html#SIMBOLO
#! http://joostje.komputilo.org/KompLeks/html/JX.html#JxETONO


#! Stream -> fluo
#! Warning -> averto


# Avertoj pri erfluoj
## TokensStream warnings


msg.bad.octal.literal =\
        malkongrua okuma  la\u016dlitera cifero {0}; interpretu \u011din kiel dekuma \u0109ifro
        #illegal octal literal digit {0}; interpreting it as a decimal digit


msg.reserved.keyword =\
        malregula uzado de estonteca rezervita bazsimbolo {0};
        #illegal usage of future reserved keyword {0}; interpreting it as ordinary identifier


#! LiveConnect temas pri pontoj inter Java kaj Javaskripto, tio estas "trans-\u0135av-il-aro"
# trans\u0135averaroj 
## LiveConnect errors


msg.Java.internal.field.type =\
        Ena eraro: transtipado de {0} por asigni al {1} je {2} malfunkciis.
        #Internal error: type conversion of {0} to assign to {1} on {2} failed.


msg.Java.conversion.implicit_method =\
        Ne povas trovi transtipilan metodon "{0}" je klaso {1}.
        #Can''t find converter method "{0}" on class {1}.


msg.Java.method.assign =\
        Java metodo "{0}" malalsignebla.
        #Java method "{0}" cannot be assigned to.


# memalirebla/idalirebla kampo 
## access private/protected field
msg.Java.internal.private =\
        Ena eraro: provo aliri memalireblan/idalireblan kampon "{0}".
        #Internal error: attempt to access private/protected field "{0}".


msg.Java.no_such_method =\
        Ne povas trovi metodo {0}.
        #Can''t find method {0}.


msg.script.is.not.constructor =\
        Skriptobjektoj ne estas konstruiloj.
        #Script objects are not constructors.


msg.nonJava.method =\
        Java metodo "{0}" elvokita kun {1} kiel "tiu-\u0109i" valoro, kiun ne povas esti konverti al Java tipo {2}.
        #Java method "{0}" was invoked with {1} as "this" value that can not be converted to Java type {2}.


#! instance -> klasano
#! instance -> tipano
#! field -> kampo


msg.Java.member.not.found =\
        Java klaso "{0}" ne havas publikan instancan kampon a\u016d metodon nomitan "{1}".
        #Java class "{0}" has no public instance field or method named "{1}".


#! array -> vico kiam estas nur unu dimensio 
#! array -> tabelo \u011denerale
msg.Java.array.index.out.of.bounds =\
        Tabelindico {0} eksteriras la intervalo [0..{1}].
        #Array index {0} is out of bounds [0..{1}].


msg.Java.array.member.not.found =\
        Java tabeloj ne havas eksteralirajn klasulajn kampojn a\u016d iloj nomitajn "{0}".
        #Java arrays have no public instance fields or methods named "{0}".


msg.pkg.int =\
        Java paka\u011dnomoj ne povas esti numbroj.
        #Java package names may not be numbers.


msg.access.prohibited =\
        Aliro al Java klaso "{0}" malpermisita.
        #Access to Java class "{0}" is prohibited.


# importil-supr-nivelo
## ImporterTopLevel
msg.ambig.import =\
        Dubsignifa importo: "{0}" kaj "{1}".
        #Ambiguous import: "{0}" and and "{1}".


msg.not.pkg =\
        Funkcio "pakenportu" vokendas kun paka\u011do; donita "{0}" anstata\u016d.  
        #Function importPackage must be called with a package; had "{0}" instead.


msg.not.class =\
        Funkctio "klasenportu" vokendas kun klaso; donita "{0}" anstata\u016d.  
        #Function importClass must be called with a class; had "{0}" instead.


msg.not.class.not.pkg =\
        "{0}" estas nek klaso nek paga\u011do.
        #"{0}" is neither a class nor a package.


msg.prop.defined =\
        Ne povas importi "{0}" \u0109ar eco kun tiu nomo jam estas difinita.
        #Cannot import "{0}" since a property by that name is already defined.


#Javadaptilo
##JavaAdapter
msg.adapter.zero.args =\
        Javadaptilo necesas alemena\u016d unu argumento. 
        #JavaAdapter requires at least one argument.


msg.not.Java.class.arg = \
Argumento {0} ne estas Java klaso: {1}.
#Argument {0} is not Java class: {1}.


#Javadaptilo
##JavaAdapter
msg.only.one.super = \
Nur unu klaso povas esti klaidita per Javadaptilo. Ricevi {0} kaj {1}.
#Only one class may be extended by a JavaAdapter. Had {0} and {1}.


# Tabeloj
## Arrays
msg.arraylength.bad =\
        Malkongrua tabellongo.
        #Inappropriate array length.


# Tabeloj
## Arrays
#! exceed -> superi
#! support -> apog/i
#! unsupported (type, etc.)-> malkungrua (tipo, ktp.)
msg.arraylength.too.big =\
        tabellongo {0} superas limon de apogita kapacito
        #Array length {0} exceeds supported capacity limit.


# URI
## URI
msg.bad.uri =\
        Misformita URI sekv\u00e2jo.
        #Malformed URI sequence.


# Nombro
## Number


#! ekster- intervalo iri
msg.bad.precision =\
        Precizo {0} eksterintervaliras.
        #Precision {0} out of range.


#! generate -> generi 
#! send (to function) -> provizi (al funkcio)
#! send (through network) -> al\u015duti


# la\u016dbazgenerilo
## NativeGenerator
msg.send.newborn =\
  Provu provizi valoron al novula generilo
  #Attempt to send value to newborn generator


msg.already.exec.gen =\
        Jam rulanta generilo
        #Already executing generator
    
#! Stop -> halt
#! iterate -> cikli (prefere al "iteracii" a\u016d "ripetadi")
#! iteration -> ciklado (prefere al "iteracio", a\u016d "ripetado")
#! iterator -> ciklilo (prefere al "iteraciilo")
msg.StopIteration.invalid =\
        haltciklo mal\u015dan\u011deblas al arbitra objekto.
        #StopIteration may not be changed to an arbitrary object.


# Interpretilo
## Interpreter
msg.yield.closing =\
  Liverado ekde malapertanta generilo
  #Yield from closing generator


# Nova babilscripta a\u0135o 
# New Babylscript Stuff
msg.unknown.language.mode =\
  Nelkonata lingva modo
  #Unknown language mode
