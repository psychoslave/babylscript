#
# Default JavaScript messages file.
#
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is Rhino code, released
# May 6, 1999.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1997-1999
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Norris Boyd
#   Bob Jervis
#
# Alternatively, the contents of this file may be used under the terms of
# the GNU General Public License Version 2 or later (the "GPL"), in which
# case the provisions of the GPL are applicable instead of those above. If
# you wish to allow use of your version of this file only under the terms of
# the GPL and not to allow others to use your version of this file under the
# MPL, indicate your decision by deleting the provisions above and replacing
# them with the notice and other provisions required by the GPL. If you do
# not delete the provisions above, a recipient may use your version of this
# file under either the MPL or the GPL.
#
# ***** END LICENSE BLOCK *****

# This is replaced during jar assembly from property string
# and should not be translated
implementation.version = @IMPLEMENTATION.VERSION@

#
# To add JavaScript error messages for a particular locale, create a
# new Messages_[locale].properties file, where [locale] is the Java
# string abbreviation for that locale.  For example, JavaScript
# messages for the Polish locale should be located in
# Messages_pl.properties, and messages for the Italian Swiss locale
# should be located in Messages_it_CH.properties.  Message properties
# files should be accessible through the classpath under
# org.mozilla.javascript.resources
#
# See:
# java.util.ResourceBundle
# java.text.MessageFormat
#

# SomeJavaClassWhereUsed

# Codegen
msg.dup.parms =\
	Zduplikowana nazwa parametru "{0}".
#    Duplicate parameter name "{0}".

msg.too.big.jump =\
	Program jest zbyt z\u0142o\u017cony. Zbyt du\u017cy offset skoku.
#    Program too complex: too big jump offset.

msg.too.big.index =\
	Program jest zbyt z\u0142o\u017cony. Wewn\u0119trzny indeks przekroczy\u0142 limit 64K.
#    Program too complex: internal index exceeds 64K limit.

msg.while.compiling.fn =\
 	B\u0142\u0105d podczas generowania kodu podczas kompilacji funkcji "{0}": {1}
#    Encountered code generation error while compiling function "{0}": {1}

msg.while.compiling.script =\
	B\u0142\u0105d podczas generowania kodu podczas kompilacji sktyptu: {0}
#	Encountered code generation error while compiling script: {0}

# Context
msg.ctor.not.found =\
	Nie znaleziono konstruktora dla "{0}".
#    Constructor for "{0}" not found.

msg.not.ctor =\
	"{0}" nie jest konstruktorem.
#    "{0}" is not a constructor.

# FunctionObject
# Do not translate "(Context cx, Object[] args, Function ctorObj, boolean inNewExpr)"
msg.varargs.ctor =\
	Metoda lub konstruktor "{0}" musi by\u0107 statyczny i mie\u0107 sygnatur\u0119 \
	"(Context cx, Object[] args, Function ctorObj, boolean inNewExpr)" \
	aby zdefiniowa\u0107 konstruktor ze zmienn\u0105 liczb\u0105 parametr\u00f3w.
#    Method or constructor "{0}" must be static with the signature \
#    "(Context cx, Object[] args, Function ctorObj, boolean inNewExpr)" \
#    to define a variable arguments constructor.

# Do not translate "(Context cx, Scriptable thisObj, Object[] args, Function funObj)"
msg.varargs.fun =\
	Metoda "{0}" musi by\u0107 statyczna z sygnatur\u0105
	"(Context cx, Scriptable thisObj, Object[] args, Function funObj)" \
	aby zdefiniowa\u0107 funkcj\u0119 ze zmienn\u0105 liczb\u0105 parametr\u00f3w.
#    Method "{0}" must be static with the signature \
#    "(Context cx, Scriptable thisObj, Object[] args, Function funObj)" \
#    to define a variable arguments function.

msg.incompat.call =\
	Metoda "{0}" wywo\u0142ana z niew\u0142a\u015bciwym obiektem.
#    Method "{0}" called on incompatible object.

msg.bad.parms =\
	Nieobs\u0142ugiwany typ parametru "{0}" w metodzie "{1}".
#    Unsupported parameter type "{0}" in method "{1}".

msg.bad.method.return =\
	Nieobs\u0142ugiwany typ "{0}" zwracany przez metod\u0119 "{1}".
#    Unsupported return type "{0}" in method "{1}".
    
msg.bad.ctor.return =\
	Tworzenie obiekt\u00f3w typu "{0}" jest nieobs\u0142ugiwane.
#    Construction of objects of type "{0}" is not supported.
    
msg.no.overload =\
	Metoda "{0}" wyst\u0119puje wielokrotnie w klasie "{1}".
#    Method "{0}" occurs multiple times in class "{1}".
    
msg.method.not.found =\
	Metoda "{0}" nie znaleziono w "{1}".
#    Method "{0}" not found in "{1}".
    
# IRFactory

msg.bad.for.in.lhs =\
	Nieprawid\u0142owy lewy argument w p\u0119tli ******TODOfor..in.
#    Invalid left-hand side of for..in loop.
    
msg.mult.index =\
	Tylko jedna zmienna jest dozwolona w p\u0119tli ****TODO.
#    Only one variable allowed in for..in loop.
    
msg.bad.for.in.destruct =\
	Lewa strona dla p\u0119tli #####TODO musi by\u0107 tablic\u0105 o d\u0142ugo\u015bci 2.
#    Left hand side of for..in loop must be an array of length 2 to accept \
#    key/value pair.
    
msg.cant.convert =\
	Nie mo\u017cna przeprowadzi\u0107 konwersji do typu "{0}".
#    Can''t convert to type "{0}".
    
msg.bad.assign.left =\
	Nieprawid\u0142owe przypisanie dla lewej strony.
#    Invalid assignment left-hand side.

msg.bad.decr =\
	Niepoprawny operator dekrementacji.
#    Invalid decrement operand.

msg.bad.incr =\
    Niepoprwany operator inkrementacji.

msg.bad.yield =\
	###TODO yeld musi znajdowa\u0107 si\u0119 w funkcji.
#    yield must be in a function.

msg.yield.parenthesized =\
	@#@##TODO wyra\u017cenie yeld musi by\u0107 w nawiasach.
#    yield expression must be parenthesized.

# NativeGlobal
msg.cant.call.indirect =\
	Funkcja "{0}" musi by\u0107 wywo\u0142ana bezspo\u015brednio a nie za po\u015brednictwem \
	funkcji o innej nazwie.
#    Function "{0}" must be called directly, and not by way of a \
#    function of another name.

msg.eval.nonstring =\
	Wywo\u0142anie ####@#@eval() z czym\u015b innym ni\u017c prosty \u0142a\u0144cuch \\
	tylko zwr\u00f3ci warto\u015b\u0107. Czy to w\u0142a\u015bnie mia\u0142e\u015b na my\u015bli?
#    Calling eval() with anything other than a primitive string value will \
#    simply return the value. Is this what you intended?

msg.eval.nonstring.strict =\
	Wywo\u0142anie ##@#eval() z czym\u015b innym ni\u017c prosty \u0142a\u0144cych jest niedozwolne \
	w trybie rygorystycznym.
#    Calling eval() with anything other than a primitive string value is not \
#    allowed in strict mode.

msg.bad.destruct.op =\
	Niedozwony opertor przypisania z dekonstrukcj\u0105.
#    Invalid destructuring assignment operator

# NativeCall
msg.only.from.new =\
	"{0}" mo\u017ce by\u0107 wywo\u0142any tylko z wyra\u017cenia ####TODO"new".
#    "{0}" may only be invoked from a "new" expression.

msg.deprec.ctor =\
	Konstruktor "{0}" jest zdeprekowany.
#    The "{0}" constructor is deprecated.

# NativeFunction
msg.no.function.ref.found =\
	brak \u017ar\u00f3d\u0142a aby zdekompiloa\u0107 referencj\u0119 do funkcji {0}
#    no source found to decompile function reference {0}

msg.arg.isnt.array =\
	drugi argument w #@#@#@#Function.prototype.apply musi by\u0107 tablic\u0105.
#    second argument to Function.prototype.apply must be an array

# NativeGlobal
msg.bad.esc.mask =\
	niepoprawna maska dla ?????przetwarzania \u0142a\u0144cucha.
#    invalid string escape mask

# NativeJavaClass
msg.cant.instantiate =\
	b\u0142ad podczas tworzenie instancji dla ({0}): klasa {1} jest abstrakcyjna lub jest interfejsem
#    error instantiating ({0}): class {1} is interface or abstract

msg.bad.ctor.sig =\
	Znaleziono konstruktor z nieprawid\u0142ow\u0105 sygnatur\u0105: \
	{0} wywo\u0142uje {1} z sygnatura {2}
#    Found constructor with wrong signature: \
#    {0} calling {1} with signature {2}

# Do not translate getClass()
msg.not.java.obj =\
	Oczekiwano, \u017ce argument dla #@#@getClass b\u0119dzie obiektem Java.
#    Expected argument to getClass() to be a Java object.

msg.no.java.ctor =\
	Nie znaleziono konstruktor Javowego dla "{0}" z argumentami "{1}".
#    Java constructor for "{0}" with arguments "{1}" not found.

# NativeJavaMethod
msg.method.ambiguous =\
	Wyb\u00f3r metody Javowej metody {0}.{1} dla typ\u00f3w argument\u00f3w JavaScriptowych
	({2}) jest niejdnoznaczny; \
	kandydatami s\u0105: {3}
#    The choice of Java method {0}.{1} matching JavaScript argument types ({2}) is ambiguous; \
#    candidate methods are: {3}

msg.constructor.ambiguous =\
	Wyb\u00f3r metody konstruktora Javowego {0} dla typ\u00f3w argument\u00f3w JavaScriptowych
	({2}) jest niejdnoznaczny; \
	kandydatami s\u0105: {3}
#    The choice of Java constructor {0} matching JavaScript argument types ({1}) is ambiguous; \
#    candidate constructors are: {2}

# NativeJavaObject
msg.conversion.not.allowed =\
	Nie mo\u017cna przeprowadzi\u0107 konwersji z {0} na {1}
#    Cannot convert {0} to {1}

msg.no.empty.interface.conversion =\
	Nie mo\u017cna przeprowadzi\u0107 konwersji z {0} do interfejsu {1} przy braku metod.
#    Cannot convert {0} to interface {1} with no methods

msg.no.function.interface.conversion =\
	Nie mo\u017cna przeprowadzi\u0107 kowersji {0} do intersu poniewa\u017c zawiera
	metody o r\u00f3\u017cnych sygnaturach.
#    Cannot convert function {0} to interface since it contains methods with \
#    different signatures

# NativeJavaPackage
# Do not translate Packages, java.lang.Classloader
msg.not.classloader =\
	Konstruktror dla "Packages" oczekuje argument\u00f3w typu java.lang.Classloader
#    Constructor for "Packages" expects argument of type java.lang.Classloader

# NativeRegExp
msg.bad.quant =\
	Nieprawid\u0142owy kwalifikator {0}
#    Invalid quantifier {0}

msg.overlarge.backref =\
	Zbyt du\u017ca wsteczna referencja {0}
#    Overly large back reference {0}

msg.overlarge.min =\
	Zbyt du\u017ce minimum {0}
#    Overly large minimum {0}

msg.overlarge.max =\
	Zbyt du\u017ce maksimum {0}
#    Overly large maximum {0}

msg.zero.quant =\
	Zerowy kwalifikator {0}
#    Zero quantifier {0}

msg.max.lt.min =\
	Maksimum {0} jest mniejsze ni\u017c minimum.
#    Maximum {0} less than minimum

msg.unterm.quant =\
	Niezako\u0144czony kwalifikator {0}
#    Unterminated quantifier {0}

msg.unterm.paren =\
	Niezako\u0144czony 2#@##@#@??? {0}
#    Unterminated parenthetical {0}

msg.unterm.class =\
	Niezako\u0144czona klasa znak\u00f3w {0}
#    Unterminated character class {0}

msg.bad.range =\
	Nieprawid\u0142owy zakres z klasie znak\u00f3w.
#    Invalid range in character class.

msg.trail.backslash =\
	Wyra\u017cenie regularne rozpoczynaj\u0105ce si\u0119 od \\ .
#    Trailing \\ in regular expression.

msg.re.unmatched.right.paren =\
	niezr\u00f3wnowa\u017cony ) w wyra\u017ceniu regularnym.
#    unmatched ) in regular expression.

msg.no.regexp =\
	Wyra\u017cenia regularne nie s\u0105 dost\u0119pne.
#    Regular expressions are not available.

msg.bad.backref =\
	liczba referencji wstecznych przekracza liczb\u0119 przechwytuj\u0105cych nawias\u00f3w.
#    back-reference exceeds number of capturing parentheses.

msg.bad.regexp.compile =\
	Tylko jeden argument mo\u017ce by\u0107 u\u017cyty je\u015bli pierwszym argumentem dla \
	RegExp.prototype.compile jest obiek RegExp.
#    Only one argument may be specified if the first argument to \
#    RegExp.prototype.compile is a RegExp object.

# Parser
msg.got.syntax.errors = \
	Podczas kompilacji wyst\u0105pi\u0142o {0} b\u0142\u0119d\u00f3w sk\u0142adniowych.
#    Compilation produced {0} syntax errors.

msg.var.redecl =\
	B\u0142ad typu: ponowna deklaracja zmiennej {0}.
#    TypeError: redeclaration of var {0}.

msg.const.redecl =\
	B\u0142\u0105d typu: Ponowna dekleracja sta\u0142ej {0}.
#    TypeError: redeclaration of const {0}.
    
msg.let.redecl =\
	B\u0142ad typu: ponowna deklaracja zmiennej {0}.
#    TypeError: redeclaration of variable {0}.

msg.parm.redecl =\
	B\u0142ad typu: ponowna dekleracja parametru formalnego {0}.
#	TypeError: redeclaration of formal parameter {0}.
	
msg.fn.redecl =\
	B\u0142\u0105d typu: ponowna deklaracja dla funkcji {0}.
#    TypeError: redeclaration of function {0}.

msg.let.decl.not.in.block =\
	B\u0142\u0105d sk\u0142adniowy : deklaracja "niech" nie jest dozwolona w bloku
#    SyntaxError: let declaration not directly within block

# NodeTransformer
msg.dup.label =\
	zduplikowana etykieta
#    duplicated label

msg.undef.label =\
	brak definicji dla etykiety
#    undefined label

msg.bad.break =\
	"przerwij" bez etykiety mo\u017ce znajdowa\u0107 si\u0119 tylko w p\u0119tli lub w wyra\u017ceniu ##@#@@TODO
#    unlabelled break must be inside loop or switch

msg.continue.outside =\
	"dalej" mo\u017ce znajdowa\u0107 si\u0119 tylko w p\u0119tli
#    continue must be inside loop

msg.continue.nonloop =\
	"dalej" mo\u017ce u\u017cy\u0107 tylko etykiet dla wyra\u017ce\u0144 iteruj\u0105cych
#    continue can only use labeles of iteration statements

msg.bad.throw.eol =\
	Zako\u0144czenie linii nie jest dozwolone pomi\u0119cy s\u0142owem kluczowym ''rzu\u0107'' \
	a wyra\u017ceniem ''rzu\u0107''.
#    Line terminator is not allowed between the throw keyword and throw \
#    expression.

msg.no.paren.parms =\
	brakuje ( przed parametrami funkcji.
#    missing ( before function parameters.

msg.no.parm =\
	brak parametru formalnego
#    missing formal parameter

msg.no.paren.after.parms =\
	brakuje ) po parametrach formalnych
#    missing ) after formal parameters

msg.no.brace.body =\
	brakuje '{' przed cia\u0142em funkcji
#    missing '{' before function body

msg.no.brace.after.body =\
	brakuje } po ciele funkcji
#    missing } after function body

msg.no.paren.cond =\
	brakuje ( przed warunkiem
#    missing ( before condition

msg.no.paren.after.cond =\
	brakuje ) po warunku
#    missing ) after condition

msg.no.semi.stmt =\
	brakuje ; przed wyra\u017cenim
#    missing ; before statement

msg.no.name.after.dot =\
	brakuje nazwy po operatorze .
#    missing name after . operator

msg.no.name.after.coloncolon =\
	brakuje nazwy po operatorze ::
#    missing name after :: operator

msg.no.name.after.dotdot =\
	brakuje nazwy po operatorze ..
#    missing name after .. operator

msg.no.name.after.xmlAttr =\
	brakuje nazwy po .@
#    missing name after .@

msg.no.bracket.index =\
	brakuje ] przed wyra\u017ceniem indeksu
#    missing ] in index expression

msg.no.paren.switch =\
	brakuje ( przed wyra\u017ceniem ''opcje''
#    missing ( before switch expression

msg.no.paren.after.switch =\
	brakuje ) po wyra\u017ceniu ''opcje''
#    missing ) after switch expression

msg.no.brace.switch =\
	brakuje '{' po ciele wyra\u017cenia ''opcje''
#    missing '{' before switch body

msg.bad.switch =\
	niepoprawne wyra\u017cenie ''opcje''
#    invalid switch statement

msg.no.colon.case =\
	brakuje : po wyra\u017ceniu ''opcja''
#    missing : after case expression

msg.double.switch.default =\
	zduplikowana etykieta ''domy\u015blnie'' w wyra\u017ceniu ''opcje''
#    double default label in the switch statement

msg.no.while.do =\
	brakuje ''p\u00f3ki" po ciele p\u0119tli ''powt\u00f3rz"
#    missing while after do-loop body

msg.no.paren.for =\
	brakuj\u0105cy ( po ''dla''
#    missing ( after for

msg.no.semi.for =\
	brakuj\u0105cy ; po inicjalizatorze p\u0119tli ''dla''
#    missing ; after for-loop initializer

msg.no.semi.for.cond =\
	brakuj\u0105cy ; po warunku p\u0119tli ''dla''
#    missing ; after for-loop condition
    
msg.in.after.for.name =\
	brakuj\u0105cy ''w'' po ''dla''
#    missing in after for

msg.no.paren.for.ctrl =\
	brakuj\u0105cy ) po warunku p\u0119tli ''dla''
#    missing ) after for-loop control

msg.no.paren.with =\
	brakuj\u0105cy ( przed obiektem wyra\u017cenia ''z''
#    missing ( before with-statement object

msg.no.paren.after.with =\
	brakuj\u0105cy ) obiekcie wyra\u017cenia ''z''
#    missing ) after with-statement object

msg.no.paren.after.let =\
	brakuj\u0105cy ( po niech
#    missing ( after let

msg.no.paren.let =\
	brakuj\u0105cy ) po li\u015bcie zmiennych
#    missing ) after variable list

msg.no.curly.let =\
	brakuj\u0105cy } po przypisaniu ''niech''
#    missing } after let statement

msg.bad.return =\
	niepoprawny powr\u00f3t
#    invalid return

msg.no.brace.block =\
	brakuj\u0105cy } w wyra\u017ceniu z\u0142o\u017conym
#    missing } in compound statement

msg.bad.label =\
	niepoprawna etykieta
#    invalid label

msg.bad.var =\
	brak nazwy dla zmiennej
#    missing variable name

msg.bad.var.init =\
	niepoprawna inicjalizacji zmiennej
#    invalid variable initialization

msg.no.colon.cond =\
	brakuj\u0105cy : po wyra\u017ceniu warunkowym
#    missing : in conditional expression

msg.no.paren.arg =\
	brakuj\u0105cy ) po li\u015bcie argument\u00f3w
#    missing ) after argument list

msg.no.bracket.arg =\
	brakuj\u0105cy ] po li\u015bcie elemnt\u00f3w
#    missing ] after element list

msg.bad.prop =\
	niew\u0142a\u015bciwy id w\u0142a\u015bciwo\u015bci
#    invalid property id

msg.no.colon.prop =\
	brakuj\u0105cy : po id w\u0142a\u015bciwo\u015bci
#    missing : after property id

msg.no.brace.prop =\
	brakuj\u0105cy } po li\u015bcie w\u0142a\u015bciwo\u015bci
#    missing } after property list

msg.no.paren =\
	brakuj\u0105cy ) w nawiasach
#    missing ) in parenthetical

msg.reserved.id =\
	identyfikator jest s\u0142owem zastrze\u017conym
#    identifier is a reserved word

msg.no.paren.catch =\
	brakuj\u0105cy ( przed warunkiem bloku ''z\u0142ap''
#    missing ( before catch-block condition

msg.bad.catchcond =\
	niepoprawny warunek bloku ''z\u0142ap''
#    invalid catch block condition

msg.catch.unreachable =\
	wszystkie wyra\u017cenia ''z\u0142ap'' po ''z\u0142ap'' bez kwalifikatora s\u0105 nieosi\u0105galne
#    any catch clauses following an unqualified catch are unreachable

msg.no.brace.try =\
	brakuj\u0105cy '{' przed blokiem spr\u00f3buj
#    missing '{' before try block

msg.no.brace.catchblock =\
	brakuj\u0105cy '{' przed blokiem ''z\u0142ap''
#    missing '{' before catch-block body

msg.try.no.catchfinally =\
	''spr\u00f3buj'' bez ''z\u0142ap'' lub ''zawsze''
#    ''try'' without ''catch'' or ''finally''

msg.no.return.value =\
  funkcja {0} nie zawsze zwraca warto\u015b\u0107
#  function {0} does not always return a value

msg.anon.no.return.value =\
  funckja anonimowa nie zawsze zwraca warto\u015b\u0107
#  anonymous function does not always return a value

msg.return.inconsistent =\
  wyra\u017cenie "zwr\u00f3\u0107" jest niezgodne z poprzednimi
#  return statement is inconsistent with previous usage

msg.generator.returns =\
  B\u0142\u0105dTypu: generator {0} zwraca warto\u015b\u0107
#  TypeError: generator function {0} returns a value

msg.anon.generator.returns =\
  B\u0142\u0105dTypu: anonimowy generator zwraca warto\u015b\u0107
#  TypeError: anonymous generator function returns a value

msg.syntax =\
	B\u0142\u0105d sk\u0142adniowy
#    syntax error

msg.unexpected.eof =\
	Nieoczekiwany koniec pliku
#    Unexpected end of file

msg.XML.bad.form =\
	niepoprawna sk\u0142adnia XML
#    illegally formed XML syntax

msg.XML.not.available =\
	\u015brodowisko uruchomieniowe XML nie jest dost\u0119pne
#    XML runtime not available

msg.too.deep.parser.recursion =\
	Zbyt g\u0142\u0119boka rekurencja podczas persowania
#    Too deep recursion while parsing

msg.no.side.effects =\
	Kod nie ma efektu obocznego
#    Code has no side effects

msg.extra.trailing.comma =\
	Przecinej na pocz\u0105tku nie jest dozwolony inicjalizatorze obiektu zgodnym z ECMA-262
#    Trailing comma is not legal in an ECMA-262 object initializer

msg.equal.as.assign =\
	Test r\u00f3wno\u015bci (==) zamiast przypisania (=)?
#    Test for equality (==) mistyped as assignment (=)?

msg.var.hides.arg =\
	Zmienna {0} ukrywa argument
#    Variable {0} hides argument

msg.destruct.assign.no.init =\
	Brakuje = w deklaracji dekonstrukcji
#    Missing = in destructuring declaration

# ScriptRuntime
msg.no.properties =\
	{0} nie ma w\u0142a\u015bciwo\u015bci.
#    {0} has no properties.

msg.invalid.iterator =\
	Niew\u0142a\u015bciwa warto\u015b\u0107 iteratora
#    Invalid iterator value

msg.iterator.primitive =\
	__iterator__ zwr\u00f3ci\u0142 warto\u015b\u0107 typu prostego
#    __iterator__ returned a primitive value

msg.assn.create.strict =\
	Przypisanie do niezadeklarowanej zmiennej {0}
#    Assignment to undeclared variable {0}

msg.ref.undefined.prop =\
	Referencja do niezddefiniowanej w\u0142a\u015bciwo\u015bci "{0}"
#    Reference to undefined property "{0}"

msg.prop.not.found =\
	Nie znaleziono w\u0142a\u015bciwo\u015bci {0}.
#    Property {0} not found.

msg.set.prop.no.setter =\
	Nie mo\u017cna zapisa\u0107 w\u0142a\u015bciwo\u015bci, kt\u00f3ra ma tylko metod\u0119 odczytu.
#    Cannot set property {0} that has only a getter.

msg.invalid.type =\
	Niedozowolona warto\u015b\u0107 JavaScript dla typu {0}
#    Invalid JavaScript value of type {0}

msg.primitive.expected =\
	Oczekiwano typu prostego (zamiast tego jest {0})
#    Primitive type expected (had {0} instead)

msg.namespace.expected =\
	Obiekt przestrzeni nazw oczekiwany na lewo od :: (znaleziono {0})
#    Namespace object expected to left of :: (found {0} instead)

msg.null.to.object =\
	Nie mog\u0119 skonwertowa\u0107 'brak' do obiektu.
#    Cannot convert null to an object.

msg.undef.to.object =\
	Nie mog\u0119 skonwertowa\u0107 'niezdefiniowany' do obiektu.
#    Cannot convert undefined to an object.

msg.cyclic.value =\
	Warto\u015b\u0107 cykliczna {0} jest niedozwolona.
#    Cyclic {0} value not allowed.

msg.is.not.defined =\
	"{0}" nie jest zdefiniowany.
#    "{0}" is not defined.

msg.undef.prop.read =\
	Nie mog\u0119 odczyta\u0107 w\u0142a\u015bciwo\u015bci "{1}" z {0}
#    Cannot read property "{1}" from {0}

msg.undef.prop.write =\
	Nie mo\u017cna ustawi\u0107 w\u0142a\u015bciwo\u015bci "{1}" z {0} na "{2}"
#    Cannot set property "{1}" of {0} to "{2}"

msg.undef.prop.delete =\
	Nie mo\u017cna usun\u0105\u0107 w\u0142a\u015bciwo\u015b\u0107 "{1} z {0}
#    Cannot delete property "{1}" of {0}

msg.undef.method.call =\
	Nie mo\u017cna wywo\u0142a\u0107 metody "{1}" z {0}
#    Cannot call method "{1}" of {0}

msg.undef.with =\
	Nie mo\u017cna zastosowa\u0107 "z" dla {0}
#    Cannot apply "with" to {0}

msg.isnt.function =\
	{0} nie jest funkcj\u0105, jest {1}
#    {0} is not a function, it is {1}.

msg.isnt.function.in =\
	Nie mo\u017cna wywo\u0142a\u0107 w\u0142a\u015bciwo\u015bci {0} w obiekcie {1}. Zamiast funkcj\u0105 jest "{2}".
#    Cannot call property {0} in object {1}. It is not a function, it is "{2}".

msg.function.not.found =\
	Nie mo\u017cna znale\u017a\u0107 funkcji {0}.
#    Cannot find function {0}.

msg.function.not.found.in =\
	Nie mo\u017cna znale\u017a\u0107 funkcji {0} w obiekcie {1}.
#    Cannot find function {0} in object {1}.

msg.isnt.xml.object =\
	{0} nie jest obiektem xml
#    {0} is not an xml object.

msg.no.ref.to.get =\
	{0} nie jest rederencj\u0105 do czyranej????????????????????
#    {0} is not a reference to read reference value.

msg.no.ref.to.set =\
	{0} nie jest referencj\u0105 do zbioru ??????????????????????????????
#    {0} is not a reference to set reference value to {1}.

msg.no.ref.from.function =\
	Fukcja 0} nie mo\u017ce by\u0107 u\u017cyta po lewej stronie przypisania \
	lub jako operand operatora ++ lub --.
#    Function {0} can not be used as the left-hand side of assignment \
#    or as an operand of ++ or -- operator.

# Do not translate getDefaultValue()
msg.bad.default.value =\
	Metoda getDefaultValue() obiektu musi zwraca\u0107 obiekt.
#    Object''s getDefaultValue() method returned an object.

msg.instanceof.not.object = \
	Nie mo\u017cna u\u017cy\u0107 jestinstancj\u0105 dla nie-obiektu.
#    Can''t use instanceof on a non-object.

msg.instanceof.bad.prototype = \
	w\u0142a\u015bciwo\u015b\u0107 ''prototyp'' dla {0} nie jest obiektem.
#    ''prototype'' property of {0} is not an object.

msg.bad.radix = \
	niedozwolona podstawa {0}.
#    illegal radix {0}.

# ScriptableObject
msg.default.value =\
	Nie mo\u017cna znale\u017a\u0107 warto\u015bci domy\u015blnej dla obiektu.
#    Cannot find default value for object.

msg.zero.arg.ctor =\
	Nie mo\u017cna za\u0142adowa\u0107 klasy "{0}" kt\u00f3ra nie ma konstroktora bezparametrowego.
#    Cannot load class "{0}" which has no zero-parameter constructor.

duplicate.defineClass.name =\
	Niew\u0142a\u015bciwa metoda "{0}": nazwa "{1}" jest ju\u017c w u\u017cyciu.
#    Invalid method "{0}": name "{1}" is already in use.

msg.ctor.multiple.parms =\
	Nie mo\u017cna zdefiniowa\u0107 konstruktora lub klasy {0} poniewa\u017c \
	wi\u0119cej ni\u017c jeden konstruktor ma wiele parametr\u00f3w.
#    Can''t define constructor or class {0} since more than one \
#    constructor has multiple parameters.

# Do not translate ScriptableObject
msg.extend.scriptable =\
	{0} musi rozszerza\u0107 typ ScriptableObject aby zedfiniowa\u0107 w\u0142a\u015bciwo\u015b\u0107 {1}.
#    {0} must extend ScriptableObject in order to define property {1}.

# Do not translate ScriptableObject
msg.bad.getter.parms =\
	\u017beby zdefiniowa\u0107 w\u0142a\u015bciwo\u015b\u0107, metoda odczytu {0} musi mie\u0107 zero parametr\u00f3w \
	lub jeden typu ScriptableObject.
#    In order to define a property, getter {0} must have zero parameters \
#    or a single ScriptableObject parameter.

# Do not translate ScriptableObject
msg.obj.getter.parms =\
	Oczekiwano statycznego lub zdelegowanego odczytu {0} z parametrem typu ScriptableObject.
#    Expected static or delegated getter {0} to take a ScriptableObject parameter.

msg.getter.static =\
	Metody odczytu i zapisu musz\u0105 albo obie statyczne albo \u017cadna nie mo\u017ce by\u0107.
#    Getter and setter must both be static or neither be static.

msg.setter.return =\
	Metoda zapisu musi zwraca\u0107 warto\u015b\u0107 typu nic: {0}
#    Setter must have void return type: {0}

# Do not translate ScriptableObject
msg.setter2.parms =\
	Metoda zapisu z dwoma parametrami musi przyjmowa\u0107 ScriptableObject jako pierwszy parametr.
#    Two-parameter setter must take a ScriptableObject as its first parameter.

msg.setter1.parms =\
	Oczekiwano jednego parametru dla zapisu {0}.
#    Expected single parameter setter for {0}

msg.setter2.expected =\
	Oczekiwano statycznego lub zdelegowanego zapisu {1} z dwoma parametrami.
#    Expected static or delegated setter {0} to take two parameters.

msg.setter.parms =\
	Oczekiwano jednego lub dw\u00f3ch parametr\u00f3w dla zapisu.
#    Expected either one or two parameters for setter.

msg.setter.bad.type =\
	Niew\u0142a\u015bciwy typ parametru "{0}" dla zapisu "{1}".
#    Unsupported parameter type "{0}" in setter "{1}".

msg.add.sealed =\
	Nie mo\u017cna doda\u0107 w\u0142a\u015bciwo\u015b\u0107i do zapieczentowanego obiektu: {0}.
#    Cannot add a property to a sealed object: {0}.

msg.remove.sealed =\
	Nie mo\u017cna usun\u0105\u0107 w\u0142a\u015bciwo\u015bci z zapieczentowanego obiektu: {0}.
#    Cannot remove a property from a sealed object: {0}.

msg.modify.sealed =\
	Nie mo\u017cna zmieni\u0107 w\u0142a\u015bciwo\u015bci zapieczentowanego obiektu: {0}.
#    Cannot modify a property of a sealed object: {0}.

msg.modify.readonly =\
	Nie mo\u017cna zmieni\u0107 w\u0142asno\u015bci tylko do odczytu: {0}.
#    Cannot modify readonly property: {0}.

# TokenStream
msg.missing.exponent =\
	brakuje wyk\u0142adnika
#    missing exponent

msg.caught.nfe =\
	b\u0142\u0105d formatu dla liczb
#    number format error

msg.unterminated.string.lit =\
	niezko\u0144czony \u0142a\u0144cuch znak\u00f3w
#    unterminated string literal

msg.unterminated.comment =\
	niezako\u0144czony komentarz
#    unterminated comment

msg.unterminated.re.lit =\
	niezako\u0144czone wyra\u017cenie regularne
#    unterminated regular expression literal

msg.invalid.re.flag =\
	niedozolona flaga po wyra\u017ceniu regularnym
#    invalid flag after regular expression

msg.no.re.input.for =\
	brak wej\u015bcia dla {0}
#    no input for {0}

msg.illegal.character =\
	niedozwolony znak
#    illegal character

msg.invalid.escape =\
	niew\u0142a\u015bciwa sekwencja modyfikuj\u0105ca Unicode
#    invalid Unicode escape sequence

msg.bad.namespace =\
	nie jest w\u0142a\u015bciwym wyrazeniem przestrzeni nazw. \
	Sk\u0142adnia: domy\u015blna przestrze\u0144 nazw xml = WYRA\u017bENIE;
#    not a valid default namespace statement. \
#    Syntax is: default xml namespace = EXPRESSION;

# TokensStream warnings
msg.bad.octal.literal =\
	Niedozwolona \u00f3semkowa sta\u0142a liczbowa {0}; b\u0119dzie interpretowana w systemie dziesi\u0119tnym.
#    illegal octal literal digit {0}; interpreting it as a decimal digit

msg.reserved.keyword =\
	Niedozwolone u\u017cycie zastrze\u017conego s\u0142owa kluczowego {0}; b\u0119dzie interpretowane jako zwyk\u0142y identyfikator
#    illegal usage of future reserved keyword {0}; interpreting it as ordinary identifier

# LiveConnect errors
msg.java.internal.field.type =\
	B\u0142\u0105d wewn\u0119trzny: konwersja typu {0} przy przypisaniu {2} do {1} nie uda\u0142a si\u0119. ###############Sprawdzi\u0107
#    Internal error: type conversion of {0} to assign to {1} on {2} failed.

msg.java.conversion.implicit_method =\
	Nie mo\u017cna znale\u017a\u0107 metody konweruj\u0105cej "{0}" w klasie {1}.
#    Can''t find converter method "{0}" on class {1}.

msg.java.method.assign =\
	Do metody j\u0119zyka Java "{0}" nie mo\u017ce zostosowa\u0107 przypisania.
#    Java method "{0}" cannot be assigned to.

msg.java.internal.private =\
	B\u0142\u0105d wewn\u0119trzny: pr\u00f3ba dost\u0119pu do prywatnego/chronionego pola "{0}".
#    Internal error: attempt to access private/protected field "{0}".

msg.java.no_such_method =\
	Nie mo\u017cna znale\u017a\u0107 metody {0}.
#    Can''t find method {0}.

msg.script.is.not.constructor =\
	Obiekty skryptu nie s\u0105 konstruktorami.
#    Script objects are not constructors.

msg.nonjava.method =\
	Metoda j\u0119zyka Java "{0}" zosta\u0142a wywo\u0142ana z {1} jako "ten", kt\u00f3ry nie mo\u017ce zosta\u0107 skonwertowany do typu Java {2}.
#    Java method "{0}" was invoked with {1} as "this" value that can not be converted to Java type {2}.

msg.java.member.not.found =\
	Klasa j\u0119zyka Java "{0"} nie ma publicznej metody lub pola "{1}".
#    Java class "{0}" has no public instance field or method named "{1}".

msg.java.array.index.out.of.bounds =\
	Indeks elementu tablicy {0} jest poza zakresem [0..{1}].
#    Array index {0} is out of bounds [0..{1}].

msg.java.array.member.not.found =\
	Tablica Java nie ma publicznego pola lub metody "{0}".
#    Java arrays have no public instance fields or methods named "{0}".

msg.pkg.int =\
	Nazw\u0105 pakietu Java nie mo\u017ce by\u0107 liczba.
#    Java package names may not be numbers.

msg.access.prohibited =\
	Dost\u0119p do klasy Java "{0}" jest niedozwolony.
#    Access to Java class "{0}" is prohibited.

# ImporterTopLevel
msg.ambig.import =\
	Niejednoznaczny import: "{0}" i "{1}".
#    Ambiguous import: "{0}" and and "{1}".

# Do not translate importPackage 
msg.not.pkg =\
	Funkcja importPackage musi by\u0107 wywo\u0142ana z pakietem; zamiast tego jest "{0}"
#    Function importPackage must be called with a package; had "{0}" instead.

# Do not translate importClass 
msg.not.class =\
	Funkcja importClass musi by\u0107 wywo\u0142ana z klas\u0105; zamiast tego jest "{0}"
#    Function importClass must be called with a class; had "{0}" instead.

msg.not.class.not.pkg =\
	"{0}" nie jest klas\u0105 ani pakietem.
#    "{0}" is neither a class nor a package.

msg.prop.defined =\
	Nie mo\u017cna zaimportowa\u0107 "{0}" poniewa\u017c w\u0142a\u015bciwo\u015b\u0107 o takiej nazwie jest ju\u017c zdefiniowana,
#    Cannot import "{0}" since a property by that name is already defined.

#JavaAdapter
# Do not translate JavaAdapter 
msg.adapter.zero.args =\
	JavaAdapter wymaga co najmniej jednego argumentu.
#    JavaAdapter requires at least one argument.

msg.not.java.class.arg = \
Argument {0} nie jest klas\u0105 Java: {1}.
#Argument {0} is not Java class: {1}.

#JavaAdapter
msg.only.one.super = \
Tylko jedna klasa mo\u017ce by\u0107 poszerzona o JavaAdapter. Dost\u0119pne s\u0105 {0} i {1}.
# Do not translate JavaAdapter 
#Only one class may be extended by a JavaAdapter. Had {0} and {1}.

# Arrays
msg.arraylength.bad =\
	Niepoprawna d\u0142ugos\u0107 tablicy.
#    Inappropriate array length.

# Arrays
msg.arraylength.too.big =\
	D\u0142ugo\u015b\u0107 tablicy {0} przekracza limit pojemno\u015bci.
#    Array length {0} exceeds supported capacity limit.

# URI
msg.bad.uri =\
	Niepoprawna sekwencja URI.
#    Malformed URI sequence.

# Number
msg.bad.precision =\
	Precyzja {0} jest poza zakresem.
#    Precision {0} out of range.

# NativeGenerator
msg.send.newborn =\
  Pr\u00f3ba przekazania warto\u015bci do \u015bwierzo powsta\u0142ego generatora
#  Attempt to send value to newborn generator

msg.already.exec.gen =\
	Wykonywanie generatora jest ju\u017c w trakcie.
#    Already executing generator
    
msg.StopIteration.invalid =\
	PrzerwijIteracj\u0119 nie mo\u017ce by\u017c zmienione z dowolnego obiektu.
#    StopIteration may not be changed to an arbitrary object.

# Interpreter
msg.yield.closing =\
  Przeka\u017c z zamykanego generatora
#  Yield from closing generator

# New Babylscript Stuff
msg.unknown.language.mode =\
  Nieznany tryb j\u0119zykowy
#  Unknown language mode
